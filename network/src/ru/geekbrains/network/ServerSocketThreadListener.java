package ru.geekbrains.network;

import java.net.ServerSocket;
import java.net.Socket;

public interface ServerSocketThreadListener {
    void onServerStart(ServerSocketThread thread);
    void onServerStop(ServerSocketThread thread);
    void onServerSocketCreated(ServerSocketThread thread, ServerSocket server);
    void onServerTimeout(ServerSocketThread thread, ServerSocket server);
    void onSocketAccepted(ServerSocketThread thread, ServerSocket server, Socket socket);
    void onServerException(ServerSocketThread thread, Throwable exception);
}

/*
* 1)Когда при переопределение метода или конструктора класса убирать родетельсктий Super()
2)Как начать мыслить в сторону абстрактности при проектирование проекта, вот на примере network в приложение чата. у меня проблема такая что я хоть и стараюсь разбивать по классам или методам разграничивая функционал, но не так хорошо как хотелось бы. А тут сокеттред и в клиенте и на сервер используются, вот это да

* каким образом можно, не создавая jar-файл, запустить несколько экземпляров клиента?

* почему при использовании FileWriter, PrintStream нет реакции на \n?

Единственный вопрос по предыдущему уроку это, для чего мы все раскладывали по модулям? На первый взгляд выглядит как будто по разным папкам все разложили... Присутствовал на вебинаре и затем полностью пересмотрел урок... Понял одно что там можно както получить jar файлы и открывать через них приложения… Вот только как это делается я так и не понял... Это либо тема следующих уроков либо прошу вас просвятить меня в этом вопросе

*
Почему-то во время отключения клиента при удалении его из Vector методом .remove(Object o) получаю ошибку ConcurrentModificationException, а если удалять методом .remove(int index), то всё ок. С чем может быть связано?

0. Сетевые соединения, правильно ли я понял, что сокет появляется как объект только в случае соединения с сокетом напротив(клиент->сервер), в этом случае и у клиента и у сокета появляется сокет? или у клиента он был и сокет создается только у сервера в момент подключения?
0.1. Синтаксис урока, что есть оператор finally? В каком случае он срабатывает?
Про потоки, скажите, почему мы все-время используем отдельный класс, наследник Thread, почему мы не можем реализовывать потоки через Runnable? (или так нагляднее просто, когда потоки в отдельном файле?)
1. Я так и не совсем понял зачем нам отпускать сервер в таймаут, когда он всеравно остановиться на interupt();? ( Как я понял мы сокет сервер ждем сокет и весим в accept() пока не появится сокет для создание нового сокета!)
2. Немного запутался в сокетах! Клиент присоеденяется к чату, у него должен быть сокет правильно? что бы мы как сервер могли его прослушать и создать новый сокет? Как клиент получает этот сокет? И что происходит с новым сокетом? Было бы неплохо схематически нарисовать процесс работы, если не займет много времени!
3. Почему мы синхронизируем методы в SocketThread классе close() и sendMessege()
-P.S Я если честно 2 раза пересматривал лекцию, коментировал код , и терял мысль всегда после ServerSocked и ServerSockedListner. Не могу задерживать группу своими вопросами, для понимания, не могли бы посоветовать дополнительный материал по сетям?

Для чего нужен порт 8189 в server socket?
Модулей может быть не ограниченное количество в проекте?
У server socket только порт в конструкторе?
Может ли быть несколько serverSocket.accept() для одного подключения?
Что должно быть передано новому подключившемуся клиенту?
Как правильно закрыть ресурсы клиента если тот захочет выйти?
1.потоки всегда нужно каждый пускать в своем треде? или есть ситуации когда мы запустили много потоков и они самостоятельно смогли все посчитать правильно?
2.на сколько актуально на джаве писать что-то, что работает через итернет. насколько часто используется?

1) Пересматривая прошлое занятие возник вопрос, при создании эхо сервера здесь по факту мы говорим ServerCocket'у методом accept: слушай порт и как только подключится клиент создай новый сокет. И в этой же строчке мы создаём Socket s = сокет? Тоесть мы создаём переменную типа Socket и присваиваем ей ссылку на этот новый сокет который создаст метод accept при подключении нового клиента, правильно я понял?
Пока писал вопрос и подбирал слова сам в общем понял)
public class EchoServer {
public static void main(String[] args) {
try (ServerSocket server = new ServerSocket(8189)) {
System.out.println("Server created");
Socket s = server.accept();
2) Вот метод из SocketThread, здесь если мы поймали IOException и не смогли передать сообщение, методом close(); мы вообще весь тред закрываем, тоесть это тот метод close который у нас там же ниже написан? В котором мы интеррапт, socket.close, in.close, out.close.
public synchronized boolean sendMessage(String msg) {
try {
out.writeUTF(msg);
out.flush();
return true;
} catch (IOException e) {
listener.onSocketException(this, e);
close();
return false;
}
}
3) КОгда мы устанавливаем таймаут например 3 секунды, это прерывание ожидания ответа? Тоесть server.accept() он ждёт ответа вешая поток но раз в 3 секунды прерывается что бы его можно было интерраптнуть, верно?

* Вопросов по коду не возникло, но есть просьба еще раз обговорить последовательность работы программы при отправке сообщения пользователем
*
как происходит отправка сообщения? То есть, в ClientGUI в методе SendMessage в созданный обьект socketThread мы отправляем сообщение (поскольку сокет создан, значит мы соединились). Далее в SocketThread мы в методе SendMessage считываем строку и отправляем ее в исходящий поток, а для сервера это становится соответственно входящим потоком. Строка пришла. Далее, строка должна уйти другому пользователю, но пользователь не в курсе что к нему должно прийти сообщение. То есть, понятно как это работает в направлении клиент-сервер, но непонятно как работает направление сервер-клиент


*/